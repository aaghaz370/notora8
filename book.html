<script>
const BACKEND_BASE = "https://notoraadminbackend-1.onrender.com";
const BOOKS_API = `${BACKEND_BASE}/api/books`;
const COMMENTS_API = `${BACKEND_BASE}/api/comments`;

let book = null;
try {
  book = JSON.parse(localStorage.getItem("selectedBook") || "null");
  if (!book) throw new Error();
} catch {
  alert("No book found, redirecting...");
  location.href = "index.html";
}

// üß© Fill Book Details
document.getElementById("bookName").textContent = book.name;
document.getElementById("bookAuthor").textContent = book.author;
document.getElementById("bookGenre").textContent = book.genre;
document.getElementById("bookRating").textContent = "‚≠ê " + (book.rating || "N/A");
document.getElementById("bookPdf").src = book.pdfUrl;

// üîñ Load Similar Books
async function loadSuggestions() {
  try {
    const res = await fetch(`${BOOKS_API}?genre=${encodeURIComponent(book.genre)}`);
    const data = await res.json();
    const grid = document.getElementById("suggestionGrid");
    grid.innerHTML = "";
    data.filter(b => b._id !== book._id).slice(0, 6).forEach(b => {
      const el = document.createElement("div");
      el.className = "suggestion-card";
      el.innerHTML = `<img src="${b.thumbnail}" alt="${b.name}"><p>${b.name}</p>`;
      el.onclick = () => {
        localStorage.setItem("selectedBook", JSON.stringify(b));
        location.href = "book.html";
      };
      grid.appendChild(el);
    });
  } catch (err) {
    console.error("Suggestions error:", err);
  }
}
loadSuggestions();

// üß† Comment System
const user = JSON.parse(localStorage.getItem("notoraUser") || "null");
const token = localStorage.getItem("notoraToken");
const commentName = document.getElementById("commentName");
const commentText = document.getElementById("commentText");
const postBtn = document.getElementById("postCommentBtn");
const commentsList = document.getElementById("commentsList");

// Disable comments for guests
if (!user || !token) {
  commentName.style.display = "none";
  commentText.disabled = true;
  commentText.placeholder = "Login to comment";
  postBtn.textContent = "Login to Comment";
  postBtn.onclick = () => location.href = "profile.html";
} else {
  commentName.style.display = "none";
  commentText.placeholder = `Write a comment as ${user.name}`;
  postBtn.onclick = postComment;
  loadComments();
}

// üì• Load Comments
async function loadComments() {
  try {
    const res = await fetch(`${COMMENTS_API}/${book._id}`);
    const comments = await res.json();
    commentsList.innerHTML = "";
    if (!comments.length) {
      commentsList.innerHTML = `<p>No comments yet.</p>`;
      return;
    }
    comments.forEach(c => renderComment(c, commentsList, 0));
  } catch (err) {
    console.error("Error loading comments:", err);
    commentsList.innerHTML = `<p>Failed to load comments.</p>`;
  }
}

// üßæ Render Main Comment
function renderComment(c, container, level) {
  const card = document.createElement("div");
  card.className = "comment-card";

  const isOwn = user && c.name === user.name;
  card.innerHTML = `
    <div class="comment-meta">
      <span class="comment-name">${c.name}</span>
      <div>
        ${isOwn ? `<button class="reply-btn" onclick="toggleMenu(event, '${c._id}', false)"><i class='fa-solid fa-ellipsis'></i></button>` : ""}
        <button class="reply-btn" onclick="openReplyBox('${c._id}', ${level})">Reply</button>
      </div>
    </div>
    <p>${c.text}</p>
    <div class="reply-box" id="reply-${c._id}"></div>
  `;

  container.appendChild(card);
  if (c.replies && c.replies.length)
    c.replies.forEach(r => renderReply(r, card.querySelector(`#reply-${c._id}`), level + 1, c._id));
}

// üßæ Render Nested Reply
function renderReply(r, container, level, parentId) {
  const replyCard = document.createElement("div");
  replyCard.className = "comment-card";
  replyCard.style.background = `rgba(255,255,255,${0.04 + level * 0.03})`;
  replyCard.style.marginLeft = `${level * 15}px`;

  const isOwn = user && r.name === user.name;
  replyCard.innerHTML = `
    <div class="comment-meta">
      <span class="comment-name">${r.name}</span>
      <div>
        ${isOwn ? `<button class="reply-btn" onclick="toggleMenu(event, '${r._id}', true, '${parentId}')"><i class='fa-solid fa-ellipsis'></i></button>` : ""}
        ${level < 2 ? `<button class="reply-btn" onclick="openReplyBox('${parentId}', ${level + 1}, '${r._id}')">Reply</button>` : ""}
      </div>
    </div>
    <p>${r.text}</p>
    <div class="reply-box" id="reply-${r._id}"></div>
  `;

  container.appendChild(replyCard);
  if (r.replies && r.replies.length)
    r.replies.forEach(sub => renderReply(sub, replyCard.querySelector(`#reply-${r._id}`), level + 1, parentId));
}

// üìù Post Comment
async function postComment() {
  const text = commentText.value.trim();
  if (!text) return alert("Please enter a comment.");
  try {
    await fetch(COMMENTS_API, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ bookId: book._id, name: user.name, text })
    });
    commentText.value = "";
    loadComments();
  } catch (err) {
    console.error("Post error:", err);
  }
}

// üí¨ Reply Box (works up to 3 levels)
function openReplyBox(commentId, level, parentReplyId = null) {
  const boxId = parentReplyId || commentId;
  const target = document.getElementById(`reply-${boxId}`);
  if (!target || target.querySelector("textarea")) return;

  const div = document.createElement("div");
  div.innerHTML = `
    <textarea placeholder="Reply as ${user.name}" style="width:100%;background:#111;color:#fff;border:none;border-radius:6px;padding:6px;margin-top:6px"></textarea>
    <button style="background:#ff416c;border:none;padding:6px 12px;border-radius:6px;color:#fff;cursor:pointer;margin-top:4px">Send</button>
  `;

  const textArea = div.querySelector("textarea");
  div.querySelector("button").onclick = async () => {
    const text = textArea.value.trim();
    if (!text) return alert("Enter reply text!");
    try {
      await fetch(`${COMMENTS_API}/reply/${commentId}`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ name: user.name, text, parentReplyId })
      });
      loadComments();
    } catch (err) {
      console.error("Reply error:", err);
    }
  };

  target.appendChild(div);
}

// ‚ãÆ Menu Toggle (Edit/Delete)
function toggleMenu(event, id, isReply = false, parentId = null) {
  event.stopPropagation();
  document.querySelectorAll(".menu-popup").forEach(m => m.remove());

  const menu = document.createElement("div");
  menu.className = "menu-popup";
  menu.style.position = "absolute";
  menu.style.background = "#222";
  menu.style.border = "1px solid #555";
  menu.style.borderRadius = "6px";
  menu.style.padding = "5px";
  menu.style.zIndex = "1000";
  menu.style.top = `${event.clientY}px`;
  menu.style.left = `${event.clientX}px`;
  menu.innerHTML = `
    <button style="background:none;border:none;color:#fff;cursor:pointer" onclick="editComment('${id}', ${isReply}, '${parentId}')">Edit</button><br>
    <button style="background:none;border:none;color:#ff4b2b;cursor:pointer" onclick="deleteComment('${id}', ${isReply}, '${parentId}')">Delete</button>
  `;
  document.body.appendChild(menu);

  document.addEventListener("click", () => menu.remove(), { once: true });
}

function editComment(id, isReply, parentId) {
  const newText = prompt("Edit your comment:");
  if (!newText) return;
  alert("Edit API not yet implemented.");
}

function deleteComment(id, isReply, parentId) {
  if (!confirm("Delete this comment?")) return;
  alert("Delete API not yet implemented.");
}

// üîñ Bookmark Button
document.getElementById("bookmarkBtn").onclick = async () => {
  const user = JSON.parse(localStorage.getItem("notoraUser") || "null");
  const token = localStorage.getItem("notoraToken");
  const key = user ? "userBookmarks" : "guestBookmarks";

  try {
    if (user && token) {
      const res = await fetch(`${BACKEND_BASE}/api/bookmarks`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${token}`,
        },
        body: JSON.stringify({ bookId: book._id }),
      });
      if (res.ok) alert("‚úÖ Book added to your bookmarks!");
      else alert("‚ö†Ô∏è Failed to save bookmark. Try logging in again.");
    } else {
      const local = JSON.parse(localStorage.getItem(key) || "[]");
      if (local.some(b => b._id === book._id)) return alert("Already bookmarked!");
      local.unshift(book);
      localStorage.setItem(key, JSON.stringify(local));
      alert("Bookmarked locally!");
    }
  } catch (err) {
    console.error("Bookmark error:", err);
    alert("‚ùå Error saving bookmark.");
  }
};
</script>
